#ifndef TIMELY_SENDER_H
#define TIMELY_SENDER_H

#include "ns3/application.h"
#include "ns3/event-id.h"
#include "ns3/ptr.h"
#include "ns3/ipv4-address.h"
#include "ns3/data-rate.h"
#include "ns3/traced-value.h"
#include "ns3/ipv4-address.h"
#include "ns3/inet-socket-address.h"
#include "ns3/ipv4-address.h"
#include "ns3/nstime.h"
#include "ns3/inet-socket-address.h"
#include "ns3/inet6-socket-address.h"
#include "ns3/socket.h"
#include "ns3/simulator.h"
#include "ns3/socket-factory.h"
#include "ns3/packet.h"
#include "ns3/uinteger.h"
#include "ns3/double.h"
#include "ns3/ipv4-end-point.h"
#include "ns3/log.h"

namespace ns3 {

	class Socket;
	class Packet;

	/**
	* \ingroup timelysenderreceiver
	* \class Timely sender
	* \brief UDP sender that implements TIMELY protocol.
	*
	*/
	
	class TimelySender : public Application
	{
	public:
		static TypeId GetTypeId(void);

		TimelySender();

		virtual ~TimelySender();

		/**
		* \brief set the remote address and port
		* \param ip remote IP address
		* \param port remote port
		*/
		void SetRemote(Ipv4Address ip, uint16_t port);
		DataRate GetSendingRate(void);
		void SetPG(uint16_t pg);
		void BufferAddBytes(uint32_t nPacket);
		std::string GetIpv4Address() const;
		int UnderLowTh(void) const;
		void SetRandomBuffer(uint8_t *buff);

		// Monza ************************
		void ReceiveCtrl(uint32_t);
		void MaximumSendingRate();
		void SetReactMode(std::string mode);
		Time CalculateWaitingTime(uint32_t nPackets);
		// End- Monza
		std::string Print() const {
			return  
				"[" +
				std::to_string(Simulator::Now().GetMicroSeconds() - 1000000) + "us" +
				", ip: " 		+ GetIpv4Address() +
				", id: " 		+ std::to_string(m_appId) +
				", m_recvd: " 	+ std::to_string(m_received) +
				", m_sent: "  	+ std::to_string(m_sent) +
				", total: " 	+ std::to_string(m_totalToBeSent) + "]";
		}

	protected:
		virtual void DoDispose(void);

	private:

		virtual void StartApplication(void);
		virtual void StopApplication(void);

		void SetupRandomBuffer(void);

		void Init();
		void ScheduleTransmit(Time dt);
		void Send(void);
		void SendBurst();
		uint32_t SendPacket();
		void Receive(Ptr<Socket> socket);
		void UpdateSendRate();
		Time GenerateRTTSample(Time ts);
		Time GetBurstDuration(DataRate rate);
		Time GetBurstDuration(uint nBytes, DataRate rate);
		void AckTimeout(uint32_t);
		uint32_t BytesInBuffer() const;
		uint32_t BytesInFly() const;
		void PacketSentSuccessfully(uint32_t);

		// Basic networking parameters. 
		Ptr<Socket> m_socket;

		Address 	m_peerAddress;
		uint16_t 	m_peerPort;
		uint16_t 	m_appId;
		uint16_t 	m_pg;
		Time 		m_ackRto;

		EventId m_sendEvent;
		EventId m_ackRtoEvent;

		// General paremetrs.
		uint64_t 				m_sent;   						// Number of sent bytes. They are not neccessary Acked.
		TracedValue<uint64_t> 	m_totalToBeSent; 				// number of packets to be sent. It will be added by burst generator.

		// burst parameters
		uint32_t m_burstSize; 			// we send these many bytes in a burst - this is the smallest unit of rate control.
		uint32_t m_burstCnt; 			// having burst definition from m_burstSize, this counts how many bursts is already sent. 
		uint32_t m_maxMsgSize;			// MAX msg/flow size generated by FlowGenerator
		uint32_t m_maxBurstSize; 		// The MAX number of bytes we send in a burst; the upper bound (and default value) for m_burstSize
		uint32_t m_pktSize; 			// packets size. 

		// Timely algorithm parameters.
		DataRate 	m_C;		// link speed in bits per second.
		DataRate 	m_initRate; // initial sending rate.
		DataRate 	m_delta;	// additive increase step in bits per second. 
		Time	 	m_t_high;	// t_high in seconds
		Time	 	m_t_low;	// t_low in seconds
		Time	 	m_min_rtt;	// min rtt in seconds.
		double		m_beta;		// beta;
		double		m_alpha;		// alpha;
		double		m_maxRateMultiple; // the rate cannot exceed this value times m_C. This simulates the fact that the host cannot send faster than link speed, minus header.
		double		m_minRateMultiple; // the rate cannot go below this value times m_C. This is mostly a safeguard.

		// Timely variables.
		TracedValue<DataRate> 	m_rate; // current sending rate.
		Time 					m_prev_rtt; // previous RTT sample.
		TracedValue<Time> 		m_new_rtt; // new RTT sample.
		Time 					m_rtt_diff; // new RTT diff
		double 					m_HAI; // 5 if we are in HAI mode, 1 otherwise.

		// Bookkeeping
		Time 		m_sleep;  // time it takes to send all the burst packets: m_burst_size / rate
		TracedValue<uint32_t> m_received; // The lastest ACK sequencce number receieved. Sequence number equals the number of packets and always start from zero for each connection
		Time 		m_sdel; // serialization delay := time it takes to send a single packet := pktSize / rate
		DataRate 	m_maxRate;
		DataRate 	m_minRate;

		uint8_t 	*m_randomBuffer; // Packet payload to send!


		bool m_highPriority;
		int m_reactMode;					// How to react to burst! Only if low priority app.

	};

} // namespace ns3

#endif /* TIMELy_SENDER_H */